<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cyber Crossword ‚Äì Interconnected & Numbered</title>
<style>
  :root{
    --bg:#f8f8f8; --ink:#222; --muted:#666; --accent:#1f6ef3;
    --grid:#000; --cell:#fff; --block:#d9d9d9; --good:#0f9d58; --bad:#d93025;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:500 16px/1.5 Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1000px;margin:0 auto;padding:18px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .hud{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  .chip{background:#fff;border:1px solid #ddd;border-radius:999px;padding:6px 10px}
  .layout{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:900px){.layout{grid-template-columns:minmax(380px,1fr) 360px}}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.05)}
  .card .body{padding:12px}

  /* Grid */
  .grid{
    --n:11;
    display:grid;
    grid-template-columns:repeat(var(--n),minmax(0,1fr));
    width:min(92vw,560px);
    aspect-ratio:1;
    border:3px solid var(--grid);
    margin:10px auto;
    user-select:none;
    background:#fff;
  }
  .cell{
    position:relative;display:flex;align-items:center;justify-content:center;
    border:1px solid #999;background:var(--cell);font-weight:800;font-size:19px;cursor:pointer
  }
  .cell.block{background:var(--block);cursor:default}
  .num{position:absolute;top:2px;left:4px;font-size:10px;color:#444;font-weight:600}
  .active{outline:3px solid var(--accent);outline-offset:-3px}
  .wordHighlight{box-shadow:inset 0 0 0 4px rgba(31,110,243,.18)}
  .correct{color:var(--good)} .wrong{color:var(--bad)}

  /* Actions */
  .actions{text-align:center;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#fff;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border:none}

  /* Clues & Leaderboard */
  .clues{padding:8px 12px}
  .clues h3{margin:6px 0}
  .clue{padding:6px;border-radius:8px;margin:4px 0;cursor:pointer}
  .clue:hover{background:#f1f4ff}
  .clue.active{background:#e6efff;border-left:3px solid var(--accent)}
  .clue small{color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-size:14px;margin-top:6px}
  th,td{padding:6px;border-bottom:1px solid #eee;text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>üß† Cyber Crossword</h1>
    <div class="hud">
      <div class="chip">‚è± <span id="timer">00:00</span></div>
      <div class="chip">‚≠ê Score: <span id="score">0</span></div>
    </div>
  </header>

  <section class="layout">
    <!-- LEFT: GRID -->
    <div class="card">
      <div class="body">
        <div id="grid" class="grid"></div>
        <input type="text" id="hiddenInput" maxlength="1" style="position:absolute;opacity:0;pointer-events:none;" />
        <div class="actions" style="margin-top:8px">
          <button id="check">Check answers</button>
          <button id="reveal">Reveal a letter</button>
          <button id="solve">Show solution</button>
          <button id="restart">Restart</button>
          <button id="submit" class="primary">Submit score</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: CLUES + LEADERBOARD -->
    <aside class="card">
      <div class="body clues">
        <h3>Across</h3>
        <div id="cluesAcross"></div>
        <h3 style="margin-top:12px">Down</h3>
        <div id="cluesDown"></div>
        <h3 style="margin-top:14px">üèÜ Leaderboard (Top 10)</h3>
        <table>
          <thead><tr><th>Player</th><th>Score</th><th>Time(s)</th></tr></thead>
          <tbody id="boardBody"><tr><td colspan="3">Loading‚Ä¶</td></tr></tbody>
        </table>
      </div>
    </aside>
  </section>

  <footer style="text-align:center;margin-top:10px;color:#777;font-size:13px">
    Light newspaper style ¬∑ Intersections + numbering ¬∑ Click a clue or cell to highlight its word
  </footer>
</div>

<script>
/* =========================
   Settings / Data
========================= */
const ENDPOINT = "https://script.google.com/macros/s/AKfycbwAeFpW8HcizrRrZVVRL4WYLaZwoOIpeiQxKTHnvTuPqBIxJ9nUUVZtaoWk3XKwYw0/exec";

/* Grid size: 11√ó11, with border blocks for clarity
   ACROSS defines each placed word with row/col start and answer text.
   You can move words or add more; blocks are generated automatically. */
const SIZE = 11;
const ACROSS = [
  { n:1,  row:1, col:1, answer:"FIREWALL", clue:"Device that filters network traffic." },   // c1..8
  { n:2,  row:2, col:3, answer:"ENCRYPT",  clue:"Convert plaintext into ciphertext." },     // c3..9
  { n:3,  row:3, col:1, answer:"ROUTER",   clue:"Forwards packets between networks." },     // c1..6
  { n:4,  row:4, col:4, answer:"MALWARE",  clue:"Malicious software umbrella term." },      // c4..10
  { n:5,  row:5, col:3, answer:"PROXY",    clue:"Intermediary server that forwards requests." }, // c3..7
  { n:6,  row:6, col:2, answer:"PASSWORD", clue:"Secret string that controls access." }      // c2..9
];

/* Optional: if a DOWN entry matches one of these keys, we show the specific clue. */
const CLUES_BY_ANSWER = {
  VPN: "Secure private network tunnel.",
  AES: "Widely used symmetric cipher.",
  WORM: "Self-replicating malware.",
  IDS: "Monitors for intrusions.",
  HASH: "Fixed-length digest of data.",
  SSL: "Legacy predecessor to TLS."
};

/* =========================
   Build Solution Matrix
========================= */
const BLOCK = "#";
const solution = Array.from({length:SIZE},()=>Array(SIZE).fill(BLOCK));
ACROSS.forEach(a=>{
  for(let i=0;i<a.answer.length;i++){
    solution[a.row][a.col+i] = a.answer[i].toUpperCase();
  }
});

/* =========================
   Derive Across & Down lists with numbering
========================= */
function deriveAcrossAndDown(){
  // Across: start when cell != block and (col==0 or left is block)
  const acrossOut = [];
  const numMap = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
  ACROSS.forEach(a => numMap[a.row][a.col] = a.n); // ensure these numbers
  // Fill missing across numbers (if you add more words later)
  let autoN = Math.max(...ACROSS.map(a=>a.n)) + 1;

  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      const isStart = (c===0 || solution[r][c-1]===BLOCK);
      if(isStart){
        let word='', cc=c;
        while(cc<SIZE && solution[r][cc]!==BLOCK){ word+=solution[r][cc]; cc++; }
        // Find matching across record if exists
        let existing = ACROSS.find(a=>a.row===r && a.col===c && a.answer.length===word.length);
        let n = existing?.n ?? autoN++;
        numMap[r][c] = n;
        acrossOut.push({
          n, row:r, col:c, answer:word,
          clue: existing?.clue || (`Cyber term (${word.length} letters)`)
        });
      }
    }
  }

  // Down: start when cell != block and (row==0 or above is block)
  const downOut = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      const isStart = (r===0 || solution[r-1][c]===BLOCK);
      const continues = (r+1<SIZE && solution[r+1][c]!==BLOCK);
      if(isStart && continues){
        let word='', rr=r;
        while(rr<SIZE && solution[rr][c]!==BLOCK){ word+=solution[rr][c]; rr++; }
        // numbering: if an across number exists at this start, reuse; else assign next
        let n = numMap[r][c];
        if(n==null){ n = autoN++; numMap[r][c] = n; }
        downOut.push({
          n, row:r, col:c, answer:word,
          clue: CLUES_BY_ANSWER[word] || `Intersects (${word.length} letters)`
        });
      }
    }
  }
  return {acrossOut, downOut, numMap};
}
const {acrossOut, downOut, numMap} = deriveAcrossAndDown();

/* =========================
   State
========================= */
const $ = s => document.querySelector(s);
const gridEl = $('#grid');
const hiddenInput = $('#hiddenInput');

const state = {
  cells: Array.from({length:SIZE},()=>Array(SIZE).fill('')),
  fixed: Array.from({length:SIZE},()=>Array(SIZE).fill(false)),
  active: null,               // {r,c}
  dir: 'across',              // 'across' | 'down'
  score: 0,
  startTs: Date.now()
};

// Prefill first letter of each across (optional starter hint)
ACROSS.forEach(a=>{
  state.cells[a.row][a.col] = a.answer[0].toUpperCase();
  state.fixed[a.row][a.col] = true;
});

/* =========================
   Rendering
========================= */
function renderGrid(){
  gridEl.style.setProperty('--n', SIZE);
  gridEl.innerHTML = '';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const isBlock = solution[r][c]===BLOCK && !state.fixed[r][c];
      const cell = document.createElement('div');
      cell.className = 'cell' + (isBlock ? ' block':'');
      if(!isBlock){
        // number
        const n = numMap[r][c];
        if(n!=null){ const num = document.createElement('div'); num.className='num'; num.textContent=n; cell.appendChild(num); }
        // letter
        const val = state.cells[r][c] || '';
        cell.appendChild(document.createTextNode(val));
        // events
        cell.onclick = (e)=> {
          if(state.active && state.active.r===r && state.active.c===c){
            // toggle direction on second click
            state.dir = (state.dir==='across' ? 'down' : 'across');
          }else{
            state.active = {r,c};
            // choose direction by start preference
            state.dir = guessDir(r,c);
          }
          focusHiddenAt(e.target);
          highlightPath();
        };
      }
      gridEl.appendChild(cell);
    }
  }
  highlightPath();
}

function guessDir(r,c){
  // prefer across if it forms a valid across slot start/inside
  const leftBlock = (c===0 || solution[r][c-1]===BLOCK);
  const rightOk   = (c+1<SIZE && solution[r][c+1]!==BLOCK);
  if(leftBlock && rightOk) return 'across';
  const upBlock   = (r===0 || solution[r-1][c]===BLOCK);
  const downOk    = (r+1<SIZE && solution[r+1][c]!==BLOCK);
  if(upBlock && downOk) return 'down';
  return 'across';
}

function focusHiddenAt(target){
  const rect = target.getBoundingClientRect();
  hiddenInput.style.left = rect.left + 'px';
  hiddenInput.style.top  = rect.top  + 'px';
  hiddenInput.focus();
}

function highlightPath(){
  // clear
  [...gridEl.children].forEach(el=>{
    el.classList.remove('active','wordHighlight');
  });
  if(!state.active) return;
  const idx = (r,c)=> r*SIZE + c;
  const {r,c} = state.active;
  const activeCell = gridEl.children[idx(r,c)];
  activeCell?.classList.add('active');

  if(state.dir==='across'){
    let cc=c; while(cc>0 && solution[r][cc-1]!==BLOCK) cc--;
    while(cc<SIZE && solution[r][cc]!==BLOCK){
      gridEl.children[idx(r,cc)]?.classList.add('wordHighlight');
      cc++;
    }
  }else{
    let rr=r; while(rr>0 && solution[rr-1][c]!==BLOCK) rr--;
    while(rr<SIZE && solution[rr][c]!==BLOCK){
      gridEl.children[idx(rr,c)]?.classList.add('wordHighlight');
      rr++;
    }
  }
}

/* =========================
   Keyboard Input (invisible field)
========================= */
hiddenInput.addEventListener('input', ()=>{
  if(!state.active) return;
  const {r,c} = state.active;
  const ch = (hiddenInput.value || '').toUpperCase();
  hiddenInput.value = '';
  if(ch && /[A-Z]/.test(ch) && !state.fixed[r][c] && solution[r][c]!==BLOCK){
    state.cells[r][c] = ch;
    step(1);
    renderGrid();
  }
});
document.addEventListener('keydown', (e)=>{
  if(!state.active) return;
  if(e.key==='Backspace'){
    const {r,c} = state.active;
    if(!state.fixed[r][c]) state.cells[r][c] = '';
    step(-1);
    e.preventDefault();
    renderGrid();
  }
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){
    const d = {ArrowLeft:[0,-1],ArrowRight:[0,1],ArrowUp:[-1,0],ArrowDown:[1,0]}[e.key];
    moveBy(d[0], d[1]); e.preventDefault(); renderGrid();
  }
});
function step(dir){
  const {r,c} = state.active;
  if(state.dir==='across') moveTo(r, c+dir, 0, dir);
  else                     moveTo(r+dir, c, dir, 0);
}
function moveBy(dr,dc){
  const {r,c} = state.active;
  moveTo(r+dr, c+dc, dr, dc);
}
function moveTo(rr,cc,dr,dc){
  while(rr>=0 && rr<SIZE && cc>=0 && cc<SIZE){
    if(solution[rr][cc]!==BLOCK){ state.active={r:rr,c:cc}; return; }
    rr+=dr; cc+=dc;
  }
}

/* =========================
   Clues
========================= */
function renderClues(){
  const A = $('#cluesAcross'), D = $('#cluesDown');
  A.innerHTML=''; D.innerHTML='';
  acrossOut.forEach(a=>{
    const el = document.createElement('div');
    el.className='clue';
    el.innerHTML = `<strong>${a.n}.</strong> ${a.clue} <small>(${a.answer.length})</small>`;
    el.onclick = ()=>{ state.dir='across'; state.active={r:a.row,c:a.col}; renderGrid(); };
    A.appendChild(el);
  });
  downOut.forEach(d=>{
    const el = document.createElement('div');
    el.className='clue';
    el.innerHTML = `<strong>${d.n}.</strong> ${d.clue} <small>(${d.answer.length})</small>`;
    el.onclick = ()=>{ state.dir='down'; state.active={r:d.row,c:d.col}; renderGrid(); };
    D.appendChild(el);
  });
}

/* =========================
   Check / Reveal / Solve / Restart / Submit
========================= */
function checkAnswers(){
  let correct=0, total=0;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      total++;
      const val = state.cells[r][c];
      const cellEl = gridEl.children[r*SIZE+c];
      if(val && val===solution[r][c]){ correct++; cellEl.classList.add('correct'); cellEl.classList.remove('wrong'); }
      else if(val){ cellEl.classList.add('wrong'); cellEl.classList.remove('correct'); }
      else { cellEl.classList.remove('correct','wrong'); }
    }
  }
  state.score = Math.round((correct/total)*100);
  $('#score').textContent = state.score;
  if(correct===total){
    const secs = Math.floor((Date.now()-state.startTs)/1000);
    setTimeout(()=> alert(`üéâ Completed! Score ${state.score}% ¬∑ Time ${secs}s`), 50);
  }
}
function revealOne(){
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]!==BLOCK && !state.fixed[r][c] && state.cells[r][c]!==solution[r][c]){
        state.cells[r][c]=solution[r][c];
        renderGrid();
        return;
      }
    }
  }
}
function showSolution(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++)
    if(solution[r][c]!==BLOCK) state.cells[r][c]=solution[r][c];
  renderGrid(); alert('‚úÖ Full solution shown');
}
function restart(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++)
    if(!state.fixed[r][c] && solution[r][c]!==BLOCK) state.cells[r][c]='';
  state.score=0; $('#score').textContent='0'; state.startTs=Date.now();
  renderGrid();
}
async function submitScore(){
  const secs = Math.floor((Date.now()-state.startTs)/1000);
  const name = prompt('Enter your name to record score:') || 'Anonymous';
  try{
    await fetch(ENDPOINT,{method:'POST',headers:{'Content-Type':'application/json'},
      body: JSON.stringify({action:'add_score', player:name, theme:'crossword', score:state.score, seconds:secs})});
    alert('Score submitted!');
    fetchLeaderboard();
  }catch(e){ alert('Could not submit score.'); }
}

/* =========================
   Leaderboard
========================= */
async function fetchLeaderboard(){
  try{
    const res = await fetch(ENDPOINT + '?action=get_leaderboard');
    const json = await res.json();
    const rows = (json.rows||[]).filter(r=>String(r.theme||'').toLowerCase().includes('crossword') || true)
                                .slice(0,10);
    const tbody = $('#boardBody'); tbody.innerHTML='';
    if(!rows.length){ tbody.innerHTML='<tr><td colspan="3">No scores yet.</td></tr>'; return; }
    rows.forEach(r=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${escapeHtml(r.player||'')}</td><td>${r.score??''}</td><td>${r.seconds??''}</td>`;
      tbody.appendChild(tr);
    });
  }catch(e){
    $('#boardBody').innerHTML='<tr><td colspan="3">Could not load.</td></tr>';
  }
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',\"'\":'&#39;' }[m])) }

/* =========================
   Timer
========================= */
setInterval(()=>{
  const t=Math.floor((Date.now()-state.startTs)/1000);
  const mm=String(Math.floor(t/60)).padStart(2,'0');
  const ss=String(t%60).padStart(2,'0');
  $('#timer').textContent = `${mm}:${ss}`;
}, 1000);

/* =========================
   Boot
========================= */
renderGrid();
renderClues();
fetchLeaderboard();

$('#check').onclick = checkAnswers;
$('#reveal').onclick = revealOne;
$('#solve').onclick = showSolution;
$('#restart').onclick = restart;
$('#submit').onclick = submitScore;

</script>
</body>
</html>

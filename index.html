<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cyber Crossword ‚Äì Interlocking & Numbered</title>
<style>
  :root{
    --bg:#f8f8f8; --ink:#222; --muted:#666; --accent:#1f6ef3;
    --grid:#000; --cell:#fff; --block:#d9d9d9; --good:#0f9d58; --bad:#d93025;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:500 16px/1.5 Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1020px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .hud{display:flex;gap:10px;flex-wrap:wrap}
  .chip{background:#fff;border:1px solid #ddd;border-radius:999px;padding:6px 10px}
  .layout{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:900px){.layout{grid-template-columns:minmax(380px,1fr) 360px}}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.05)}
  .card .body{padding:12px}

  /* Grid */
  .grid{
    --n:11;
    display:grid;
    grid-template-columns:repeat(var(--n),minmax(0,1fr));
    width:min(92vw,560px);
    aspect-ratio:1;
    border:3px solid var(--grid);
    margin:10px auto;
    user-select:none;
    background:#fff;
  }
  .cell{
    position:relative;display:flex;align-items:center;justify-content:center;
    border:1px solid #999;background:var(--cell);font-weight:800;font-size:19px;cursor:pointer
  }
  .cell.block{background:var(--block);cursor:default}
  .num{position:absolute;top:2px;left:4px;font-size:10px;color:#444;font-weight:600}
  .active{outline:3px solid var(--accent);outline-offset:-3px}
  .wordHL{box-shadow:inset 0 0 0 4px rgba(31,110,243,.18)}
  .correct{color:var(--good)} .wrong{color:var(--bad)}

  .actions{text-align:center;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#fff;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border:none}

  .clues{padding:8px 12px}
  .clues h3{margin:6px 0}
  .clue{padding:6px;border-radius:8px;margin:4px 0;cursor:pointer}
  .clue:hover{background:#f1f4ff}
  .clue.active{background:#e6efff;border-left:3px solid var(--accent)}
  .clue small{color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-size:14px;margin-top:6px}
  th,td{padding:6px;border-bottom:1px solid #eee;text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>üß† Cyber Crossword</h1>
    <div class="hud">
      <div class="chip">‚è± <span id="timer">00:00</span></div>
      <div class="chip">‚≠ê Score: <span id="score">0</span></div>
    </div>
  </header>

  <section class="layout">
    <!-- LEFT: GRID -->
    <div class="card">
      <div class="body">
        <div id="grid" class="grid"></div>
        <input type="text" id="hiddenInput" maxlength="1" style="position:absolute;opacity:0;pointer-events:none;" />
        <div class="actions" style="margin-top:8px">
          <button id="check">Check answers</button>
          <button id="reveal">Reveal a letter</button>
          <button id="solve">Show solution</button>
          <button id="restart">Restart</button>
          <button id="submit" class="primary">Submit score</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: CLUES + LEADERBOARD -->
    <aside class="card">
      <div class="body clues">
        <h3>Across</h3>
        <div id="cluesAcross"></div>
        <h3 style="margin-top:12px">Down</h3>
        <div id="cluesDown"></div>
        <h3 style="margin-top:14px">üèÜ Leaderboard (Top 10)</h3>
        <table>
          <thead><tr><th>Player</th><th>Score</th><th>Time(s)</th></tr></thead>
          <tbody id="boardBody"><tr><td colspan="3">Loading‚Ä¶</td></tr></tbody>
        </table>
      </div>
    </aside>
  </section>

  <footer style="text-align:center;margin-top:10px;color:#777;font-size:13px">
    Click a clue or cell. Click the same cell again to toggle Across/Down.
  </footer>
</div>

<script>
/* ========== CONFIG ========= */
const ENDPOINT = "https://script.google.com/macros/s/AKfycbwAeFpW8HcizrRrZVVRL4WYLaZwoOIpeiQxKTHnvTuPqBIxJ9nUUVZtaoWk3XKwYw0/exec";

/* Fixed 11√ó11 matrix with letters for the solution and # for blocks.
   This guarantees rendering and interlocking words. */
const SIZE = 11;
const BLOCK = "#";

/* Interlocking layout:
   - FIREWALL across (row1 col1..8)
   - ENCRYPT down  (starts row1 col4)
   - ROUTER  down  (starts row1 col3)
   - MALWARE down  (starts row0 col6)
   You can add more letters later; just place them in the MATRIX. */
const MATRIX = [
  "######M####",  // r0: MALWARE starts here (M)
  "#FIREWALL##", // r1
  "###ON#L####", // r2: O,N from ROUTER/ENCRYPT; L from MALWARE
  "###UC#W####", // r3
  "###TR#A####", // r4
  "###EY#R####", // r5
  "###RP#E####", // r6
  "####T######", // r7
  "###########", // r8
  "###########", // r9
  "###########"  // r10
];

/* Friendly clue texts for known answers */
const CLUES_BY_WORD = {
  FIREWALL: "Device that filters network traffic.",
  ENCRYPT:  "Convert plaintext into ciphertext.",
  ROUTER:   "Forwards packets between networks.",
  MALWARE:  "Malicious software or code."
};

/* ========= BUILD SOLUTION ARRAYS ========= */
const solution = MATRIX.map(row => row.split(""));

/* ========= Derive Across + Down + Numbers ========= */
function deriveEntries(){
  const numbers = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
  const across=[], down=[];
  let next = 1;

  // helper to assign a number if none
  const ensureNum = (r,c) => {
    if(numbers[r][c]==null) numbers[r][c] = next++;
    return numbers[r][c];
  };

  // Across starts
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      const leftBlocked = (c===0 || solution[r][c-1]===BLOCK);
      const rightContinues = (c+1<SIZE && solution[r][c+1]!==BLOCK);
      if(leftBlocked && rightContinues){
        let word="", cc=c;
        while(cc<SIZE && solution[r][cc]!==BLOCK){ word += solution[r][cc]; cc++; }
        if(word.length>=3){ // ignore 1‚Äì2 letter fillers
          const n = ensureNum(r,c);
          across.push({ n, row:r, col:c, answer:word,
                        clue: CLUES_BY_WORD[word] || `Cyber term (${word.length} letters)` });
        }
      }
    }
  }
  // Down starts
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      const upBlocked   = (r===0 || solution[r-1][c]===BLOCK);
      const downCont    = (r+1<SIZE && solution[r+1][c]!==BLOCK);
      if(upBlocked && downCont){
        let word="", rr=r;
        while(rr<SIZE && solution[rr][c]!==BLOCK){ word += solution[rr][c]; rr++; }
        if(word.length>=3){
          const n = numbers[r][c]!=null ? numbers[r][c] : (numbers[r][c]=next++);
          down.push({ n, row:r, col:c, answer:word,
                      clue: CLUES_BY_WORD[word] || `Intersects (${word.length} letters)` });
        }
      }
    }
  }
  return {across, down, numbers};
}
const {across, down, numbers} = deriveEntries();

/* ========= State ========= */
const $ = s => document.querySelector(s);
const gridEl = $('#grid');
const hiddenInput = $('#hiddenInput');
const state = {
  cells: Array.from({length:SIZE},()=>Array(SIZE).fill("")),
  fixed: Array.from({length:SIZE},()=>Array(SIZE).fill(false)),
  active: null,  // {r,c}
  dir: "across",
  score: 0,
  start: Date.now()
};
// Optional: prefill first letter of FIREWALL, ENCRYPT, ROUTER, MALWARE
[{r:1,c:1},{r:1,c:4},{r:1,c:3},{r:0,c:6}].forEach(p=>{
  state.cells[p.r][p.c]=solution[p.r][p.c]; state.fixed[p.r][p.c]=true;
});

/* ========= Render Grid ========= */
function renderGrid(){
  gridEl.style.setProperty('--n', SIZE);
  gridEl.innerHTML='';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell=document.createElement('div');
      const isBlock = solution[r][c]===BLOCK && !state.fixed[r][c];
      cell.className='cell'+(isBlock?' block':'');
      if(!isBlock){
        const n = numbers[r][c];
        if(n!=null){ const num=document.createElement('div'); num.className='num'; num.textContent=n; cell.appendChild(num); }
        const val = state.cells[r][c] || '';
        cell.appendChild(document.createTextNode(val));
        cell.onclick = (e)=>{
          if(state.active && state.active.r===r && state.active.c===c){
            state.dir = state.dir==='across' ? 'down' : 'across';
          }else{
            state.active={r,c};
            state.dir = guessDir(r,c);
          }
          focusHidden(e.target);
          highlightWord();
        };
      }
      gridEl.appendChild(cell);
    }
  }
  highlightWord();
}

function guessDir(r,c){
  const leftBlocked=(c===0||solution[r][c-1]===BLOCK), rightOk=(c+1<SIZE&&solution[r][c+1]!==BLOCK);
  if(leftBlocked && rightOk) return 'across';
  const upBlocked=(r===0||solution[r-1][c]===BLOCK), downOk=(r+1<SIZE&&solution[r+1][c]!==BLOCK);
  if(upBlocked && downOk) return 'down';
  return 'across';
}

function focusHidden(target){
  const rect=target.getBoundingClientRect();
  hiddenInput.style.left=rect.left+'px';
  hiddenInput.style.top=rect.top+'px';
  hiddenInput.focus();
}

function highlightWord(){
  [...gridEl.children].forEach(el=>el.classList.remove('active','wordHL'));
  if(!state.active) return;
  const idx=(r,c)=>r*SIZE+c;
  const {r,c}=state.active;
  gridEl.children[idx(r,c)]?.classList.add('active');
  if(state.dir==='across'){
    let cc=c; while(cc>0 && solution[r][cc-1]!==BLOCK) cc--;
    while(cc<SIZE && solution[r][cc]!==BLOCK){ gridEl.children[idx(r,cc)]?.classList.add('wordHL'); cc++; }
  } else {
    let rr=r; while(rr>0 && solution[rr-1][c]!==BLOCK) rr--;
    while(rr<SIZE && solution[rr][c]!==BLOCK){ gridEl.children[idx(rr,c)]?.classList.add('wordHL'); rr++; }
  }
}

/* ========= Keyboard Input via hidden field ========= */
hiddenInput.addEventListener('input', ()=>{
  if(!state.active) return;
  const {r,c}=state.active;
  const ch=(hiddenInput.value||'').toUpperCase();
  hiddenInput.value='';
  if(/[A-Z]/.test(ch) && !state.fixed[r][c] && solution[r][c]!==BLOCK){
    state.cells[r][c]=ch;
    step(+1);
    renderGrid();
  }
});
document.addEventListener('keydown', (e)=>{
  if(!state.active) return;
  if(e.key==='Backspace'){
    const {r,c}=state.active;
    if(!state.fixed[r][c]) state.cells[r][c]='';
    step(-1); e.preventDefault(); renderGrid();
  }
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){
    const d={ArrowLeft:[0,-1],ArrowRight:[0,1],ArrowUp:[-1,0],ArrowDown:[1,0]}[e.key];
    moveBy(d[0],d[1]); e.preventDefault(); renderGrid();
  }
});
function step(dir){
  const {r,c}=state.active;
  if(state.dir==='across') moveTo(r,c+dir,0,dir);
  else moveTo(r+dir,c,dir,0);
}
function moveBy(dr,dc){
  const {r,c}=state.active; moveTo(r+dr,c+dc,dr,dc);
}
function moveTo(rr,cc,dr,dc){
  while(rr>=0&&rr<SIZE&&cc>=0&&cc<SIZE){
    if(solution[rr][cc]!==BLOCK){ state.active={r:rr,c:cc}; return; }
    rr+=dr; cc+=dc;
  }
}

/* ========= Clues ========= */
function renderClues(){
  const A=$('#cluesAcross'), D=$('#cluesDown'); A.innerHTML=''; D.innerHTML='';
  across.forEach(a=>{
    const el=document.createElement('div'); el.className='clue';
    el.innerHTML=`<strong>${a.n}.</strong> ${a.clue} <small>(${a.answer.length})</small>`;
    el.onclick=()=>{ state.dir='across'; state.active={r:a.row,c:a.col}; renderGrid(); };
    A.appendChild(el);
  });
  down.forEach(d=>{
    const el=document.createElement('div'); el.className='clue';
    el.innerHTML=`<strong>${d.n}.</strong> ${d.clue} <small>(${d.answer.length})</small>`;
    el.onclick=()=>{ state.dir='down'; state.active={r:d.row,c:d.col}; renderGrid(); };
    D.appendChild(el);
  });
}

/* ========= Check / Reveal / Solve / Restart / Submit ========= */
function checkAnswers(){
  let correct=0,total=0;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]===BLOCK) continue;
      total++;
      const val=state.cells[r][c];
      const cell=gridEl.children[r*SIZE+c];
      if(val && val===solution[r][c]){ correct++; cell.classList.add('correct'); cell.classList.remove('wrong'); }
      else if(val){ cell.classList.add('wrong'); cell.classList.remove('correct'); }
      else cell.classList.remove('correct','wrong');
    }
  }
  state.score = Math.round((correct/total)*100);
  $('#score').textContent = state.score;
  if(correct===total){
    const secs=Math.floor((Date.now()-state.start)/1000);
    setTimeout(()=>alert(`Completed! Score ${state.score}% ¬∑ Time ${secs}s`), 30);
  }
}
function revealOne(){
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(solution[r][c]!==BLOCK && !state.fixed[r][c] && state.cells[r][c]!==solution[r][c]){
        state.cells[r][c]=solution[r][c]; renderGrid(); return;
      }
    }
  }
}
function showSolution(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++)
    if(solution[r][c]!==BLOCK) state.cells[r][c]=solution[r][c];
  renderGrid(); alert('Solution shown.');
}
function restart(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++)
    if(!state.fixed[r][c] && solution[r][c]!==BLOCK) state.cells[r][c]='';
  state.score=0; $('#score').textContent='0'; state.start=Date.now();
  renderGrid();
}
async function submitScore(){
  const secs = Math.floor((Date.now()-state.start)/1000);
  const name = prompt('Enter your name to record score:') || 'Anonymous';
  try{
    await fetch(ENDPOINT,{method:'POST',headers:{'Content-Type':'application/json'},
      body: JSON.stringify({action:'add_score', player:name, theme:'crossword', score:state.score, seconds:secs})});
    alert('Score submitted!');
    fetchLeaderboard();
  }catch(e){ alert('Could not submit score.'); }
}

/* ========= Leaderboard ========= */
async function fetchLeaderboard(){
  try{
    const res = await fetch(ENDPOINT + '?action=get_leaderboard');
    const json = await res.json();
    const rows = (json.rows||[]).slice(0,10);
    const tbody = $('#boardBody'); tbody.innerHTML='';
    if(!rows.length){ tbody.innerHTML='<tr><td colspan="3">No scores yet.</td></tr>'; return; }
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `<td>${escapeHtml(r.player||'')}</td><td>${r.score??''}</td><td>${r.seconds??''}</td>`;
      tbody.appendChild(tr);
    });
  }catch(e){
    $('#boardBody').innerHTML='<tr><td colspan="3">Could not load.</td></tr>';
  }
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])) }

/* ========= Timer ========= */
setInterval(()=>{
  const t=Math.floor((Date.now()-state.start)/1000);
  const mm=String(Math.floor(t/60)).padStart(2,'0');
  const ss=String(t%60).padStart(2,'0');
  $('#timer').textContent = `${mm}:${ss}`;
}, 1000);

/* ========= Boot ========= */
renderGrid();
renderClues();
fetchLeaderboard();

$('#check').onclick = checkAnswers;
$('#reveal').onclick = revealOne;
$('#solve').onclick = showSolution;
$('#restart').onclick = restart;
$('#submit').onclick = submitScore;
</script>
</body>
</html>
